# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,2,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "MCM")
# Output the selected features
print(selected_features)
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,2,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "MCM")
# Output the selected features
print(selected_features)
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,2,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "MMCM")
# Output the selected features
print(selected_features)
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,100,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "MMCM")
# Output the selected features
print(selected_features)
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,100,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "MCM")
# Output the selected features
print(selected_features)
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,100,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "FR")
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,100,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
test_fn(test_type = "FR", data_list = data_list)
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type, data_sub)
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type="FR", data_sub)
print(paste("P-value for static features:", p_value))
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,2,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "FR")
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,100,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type="FR", data_sub)
print(paste("P-value for static features:", p_value))
data_sub
FRtest(data_sub[[1]],data_sub[[2]])
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,5,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
# X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
FRtest(data_list[[1]], data_list[[2]])
static_features <- 1:2  # Small feature subset for debugging
> data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type="FR", data_sub)
print(paste("P-value for static features:", p_value))
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,10,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
# X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type="FR", data_sub)
print(paste("P-value for static features:", p_value))
X1_signal <- rnorm(10,30,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
# X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,30,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
# X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
static_features <- 1:2  # Small feature subset for debugging
data_sub <- lapply(data_list, function(data) data[, static_features, drop = FALSE])
p_value <- test_fn(test_type="FR", data_sub)
print(paste("P-value for static features:", p_value))
setwd("/home/manish/Documents/NUS stuff/y4s1/DSA4288S-Mult/code")
source("test_fn.R")
source("tree_gen.R")
# Define the GFS algorithm with dynamic tree creation and list handling
GFS <- function(features, alpha_thresh, data_list, test_type) {
# Create the tree dynamically
tree <- create_tree(features)
# Recursive function to perform the test and select the features
recursive_test <- function(node, data_list, alpha_thresh, selected_features) {
# Get the indices of the features in the current node
current_features <- node$features
# Create a sub-list for the current node's features
data_sub <- lapply(data_list, function(data) data[, current_features, drop = FALSE])
# Perform the test and get the p-value
p_value <- test_fn(test_type, data_sub)
# # check if p-val is NA
# if (is.na(p_value)) {
#   warning("p_value is NA for features: ", paste(current_features, collapse=", "))
#   return(selected_features)  # Skip this node
# }
# Adjusted p-value for the node
adjusted_p_value <- p_value * (length(unlist(features)) / length(current_features))
# If the adjusted p-value is greater than the threshold and the node has no children, stop
if (adjusted_p_value > alpha_thresh && is.null(node$children)) {
return(selected_features)  # No significant features
}
# If the node is a leaf and has a single feature
if (adjusted_p_value <= alpha_thresh && length(current_features) == 1) {
selected_features <- c(selected_features, current_features)
return(selected_features)
}
# If the adjusted p-value is less than or equal to the threshold, check children nodes
if (!is.null(node$children)) {
for (child in node$children) {
selected_features <- recursive_test(child, data_list, alpha_thresh, selected_features)
}
}
return(selected_features)
}
# Start with the root node and an empty set of selected features
selected_features <- recursive_test(tree, data_list, alpha_thresh, c())
# Return the set of selected features
return(selected_features)
}
# Example usage:
# Mock data matrices (replace with actual data)
X1 <- MASS::mvrnorm(10, rep(0, 4), diag(2, 4))
X1_signal <- rnorm(10,30,sd=2)
X1 <- cbind(X1_signal, X1)
X2 <- MASS::mvrnorm(10, rep(0, 5), diag(1, 5))
# X3 <- MASS::mvrnorm(100, rep(0, 5), diag(3, 5))
# Define a data list
data_list <- list(X1, X2)
# Run the GFS algorithm with an alpha threshold of 0.05
alpha_thresh <- 0.05
features <- 1:5  # Example features
selected_features <- GFS(features, alpha_thresh, data_list, test_type = "FR")
# Output the selected features
print(selected_features)
